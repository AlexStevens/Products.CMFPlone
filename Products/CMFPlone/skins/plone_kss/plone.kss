/* <dtml-call expr="RESPONSE.setHeader('pragma','no-cache')"> */

/*
    The above trick to let this file not be cached does not work, unless this file is renamed to have
    a kss.dtml extension.
*/


/* General stylesheet for Plone AJAX */

/* Add class to body to allow conditional styling when kss is available */

body:load {
  action-client: addClass;
  addClass-value: kssActive;
}

ul.contentViews li a:plone-formProtectionChecked {
    action-server: replaceContentRegion;
    replaceContentRegion-tabid: nodeAttr(id, true);
    replaceContentRegion-url: nodeAttr(href);
    replaceContentRegion-error: plone-followLink;
    action-client: plone-removeLockProtection;
}

#content:load {
    evt-load-initial: false;
    action-client: initializeCollapsible;
}

/*
This loads the external links markers each time an element marked inlineEditable
is reloaded (needed to make it work with inlineEditable). However, this isn't the best,
client-performance wise.
TODO: Find a better way to "bind just once" or just bind the effectively reloaded links,
and not rebind everything
*/
#content .inlineEditable:load {
    evt-load-initial: false;
    action-client: bindExternalLinks;
}

/*
Content Menu Sections: Cut and Paste
*/
 /* Needed allowbubbling, because the menu-item is inside a span an the event selector is on the enclosing a-tag */

a.actionicon-object_buttons-cut:click {
    evt-click-preventdefault: True;
    evt-click-allowbubbling: True;
    action-server: cutObject;
}

a.actionicon-object_buttons-copy:click {
    evt-click-preventdefault: True;
    evt-click-allowbubbling: True; 
    action-server: copyObject;
}

/*
Content Menu Sections: Workflow State
*/
#plone-contentmenu-workflow dd.actionMenuContent a:click {
    evt-click-preventdefault: True;
    evt-click-allowbubbling: True; 
    action-server: changeWorkflowState;
    changeWorkflowState-url: nodeAttr(href);
}


#plone-contentmenu-workflow dd.actionMenuContent a.kssIgnore:click {
    evt-click-preventdefault: False;
    action-cancel: changeWorkflowState;
}

/* Spinner */


/* effects do not seem to like animated gifs 
#kss-spinner:spinneron {
    evt-spinneron-laziness: 1000;
    action-client: effect;
    effect-type: appear;
}

#kss-spinner:spinneroff {
    action-client: effect;
    effect-type: fade;
}
*/

#kss-spinner:spinneron {
    action-client: setStyle;
    setStyle-name: display;
    setStyle-value: block;
}

#kss-spinner:spinneroff {
    action-client: setStyle;
    setStyle-name: display;
    setStyle-value: none;
}

/*  Selector for the sharing page in plone.app.workflow.
    the search_term parameters, puts the needed info into the request
 */

#sharing-save-button:click {
  evt-click-preventdefault: true;
  action-server: updateSharingInfo;
  updateSharingInfo-kssSubmitForm: currentForm();
  updateSharingInfo-error: plone-submitCurrentForm;
}

#sharing-user-group-search:keyup {
  evt-keyup-preventdefault: true;
  evt-keyup-keycodes: 13;
  action-server: updateSharingInfo;
  updateSharingInfo-kssSubmitForm: currentForm();
}

/* Folder contents stuff */

body:load { 
    action-client: plone-initShiftDetection;
}

#folderlisting-main-table input[type="checkbox"]:change {
    action-client: plone-createCheckBoxSelection;
    plone-createCheckBoxSelection-group: 'table.listing input[type="checkbox"]';
}


#folderlisting-main-table input[type="checkbox"]:change {
    action-client: toggleClass;
    toggleClass-kssSelector: parentnode("table.listing tbody tr");
    toggleClass-classname: "selected";
}

#folderlisting-main-table:load { 
    action-client: plone-initCheckBoxSelection;
}

#portal-message:timeout {
   evt-timeout-delay: 2000;
   evt-timeout-repeat: '';
   action-client: deleteNode;
}
